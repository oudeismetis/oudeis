+++
title = "Perl hashes and a discussion on \"smart match\""
date = 2012-11-30T16:49:00Z
updated = 2012-11-30T16:49:45Z
tags = ["smart match", "hash", "perl", "dependency", "version"]
blogimport = true 
[author]
	name = "Edward Romano"
	uri = "https://plus.google.com/118036157148722337915"
+++

Below is some code I wrote a while ago for an application that had been written in Perl.<br />I was in a situation where I had to track dependencies on user actions. As an example:<br /><br /><table border="1"><tbody><tr><td>This action...</td><td>Can NOT be completed before these actions</td></tr><tr><td>action_4</td><td>action_1, action_2, action_3</td></tr><tr><td>action_3</td><td>action_2</td></tr><tr><td>action_2</td><td>action_1</td></tr></tbody></table><br />But of course I wanted to give the user the power to specify any action they wanted. (including a list of actions) So, if the code was told to do 'action_4', it would look that action up, see that actions 1, 2, and 3 needed to be completed first, and then do them. But this would have to be recursive as you can see that 'action_3' depends on 2, and 2 depends on 1. If 'action_1' is run, we also want to look it up and remove it from this list, since it is no longer a dependency for other actions.<br /><br />So I created a simple hash to keep track of all the dependencies (they can sometimes change, so it was nice to have them all in one spot.) Below is the method I ended up creating to manage those dependencies. I made it generic enough to handle any hash you feed it. It also accepts an option where you can tell it how you want it to remove dependencies.<br /><br /><pre class="brush:perl" name="code" width="100%"># Usage: remove_hash_deps([var], [hash list], [run type])<br /># Function: Will take the string provided in the first argument and see if it exists in the provided hash.<br /># If it exists, it will do one of the following depending on the 3rd argument option:<br /># this_one - Removes any hash that has the string as the key.<br /># on_this  - Removes any hash where the string appears somewhere in the value.<br /># all  - Does the first two above, but will recursively do the "on_this" removal.<br />#   by taking the keys that come from matches during the "on_this" removal.<br /><br />sub remove_hash_deps {<br /> my $target = shift;<br /> my $hash = shift;<br /> my $type = shift;<br /> my @removed;<br /><br /> if ($type eq "all" || $type eq "this_one") {<br />  if (exists $hash-&gt;{$target}) {<br />   delete($$hash{$target});<br />   unshift @removed, $target;<br />  }<br /> }<br /><br /> if ($type eq "all" || $type eq "on_this") {<br />  #my @matches = grep {$$hash{$_} ~~ /($target)/} keys %$hash;<br />  my @matches;<br /><br />  foreach my $key (keys %$hash) {<br />   my $value = $$hash{$key};<br />   if ($value =~ /($target)/) { #does $value CONTAIN a match of the following regex<br />    unshift @matches, $key;<br />   }<br />  }<br />  foreach my $match (@matches) {<br />   delete($$hash{$match});<br />   unshift @removed, $match;<br />   if ($type eq "all")<br />   {<br />    my @rec_removed = remove_hash_deps($match, $hash, $type);<br />    unshift @removed, @rec_removed;<br />   }<br />  }<br /> }<br /><br /> return @removed;<br />}<br /></pre><br />Seasoned Perl developers will notice line:23. That single line reminded me of a valuable software development lesson:<br /><br /><b><u>"Always match your development environment to production"</u></b><br /><br />That line makes use of "smart match" (~~), a useful little Perl feature added in version 5.10.0 in December 2007. That one line does all of the work of the foreach loop that follows it. There was just one problem: production wasn't using Perl 5.10.0 and wasn't going to have it for some time. As a result, I had to throw together that foreach statement at the last minute to replace that line of code.<br /><br />All too often you see developers with two or three large screen monitors for developing. Often, they'll also be given a huge development box with the latest Java, Perl, and any other tools they need or ask for. They then write their code to work in the latest version of Chrome or Firefox, and then marvel at how well everything looks at 1920x1080 resolution.<br /><br />Then, everyone is shocked when they find out that users in production are still using IE6 and have a screen resolution of 800x600.<br /><br />Some developers will take this as an important life lesson, but I also find that many will just dismiss this as "something test team should deal with" or "that's what UAT testing is for". Obviously no developer wants to be denied the latest and greatest development setup, but I think, if nothing else, each developer needs quick and easy access to somewhere they can view their code as if they were a production user.<br /><br />And if you think this doesn't happen often, <a href="http://cherryshoe.blogspot.com/">my fiancee</a> just told me she had this same issue a couple of months ago with her development team where a Regex that worked fine in <a href="http://radar.oreilly.com/2011/09/java7-features.html">Java 7</a>, wasn't compatible with Java 6 and caused things to break.<br /><br />This question of what to support and when is a bit more complicated than it at first seems, so I'll save more thoughts on this subject for another time.
